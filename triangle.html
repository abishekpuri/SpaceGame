<html>
  <head>
    <title>My first Three.js app</title>
    <style>
      body { margin: 0; }
      canvas { width: 100%; height: 100% }
    </style>
  </head>
  <body>
    <script src="libraries/three.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
    <script type="x-shader/x-vertex" id="vertexshader">
      // switch on high precision floats
      #ifdef GL_ES
      precision highp float;
      #endif
			varying vec3 vNormal;
			uniform float time;
      void main() {
				vNormal = normal;
				vec3 new_pos = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(new_pos, 1.0);
      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
      #ifdef GL_ES
      precision highp float;
      #endif
			varying vec3 vNormal;

      void main() {
        gl_FragColor = dot(vNormal, vec3(1, 1.0, 1.0)) * vec4(0.0,0.0,1.0,1.0);
      }
    </script>

    <script>
		'use strict';
    // start setup

		window.requestAnimFrame = (function(){
	      return  window.requestAnimationFrame       ||
	              window.webkitRequestAnimationFrame ||
	              window.mozRequestAnimationFrame    ||
	              window.oRequestAnimationFrame      ||
	              window.msRequestAnimationFrame     ||
	              function(/* function */ callback, /* DOMElement */ element){
	                window.setTimeout(callback, 1000 / 60);
	              };
	  	})();

    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(120, window.innerWidth/window.innerHeight, 1, 1000);

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0xffffff, 1);
		renderer.shadowMap.Enabled = true;
    document.body.appendChild(renderer.domElement);

		var objArray = [];
    // end setup

		// sphere
		function createSphere(x, y, z) {
			const RADIUS = 3;
			const SEGMENTS = 16;
			const RINGS = 16;

			const sphereUniforms = {
				// stores how much time has passed since creation
				time: {
					type: 'f',
					value: 0
				}
			}
			const material = new THREE.ShaderMaterial({
				uniforms: sphereUniforms,
				vertexShader: $('#vertexshader').text(),
				fragmentShader: $('#fragmentshader').text()
			});
			const sphereGeometry = new THREE.SphereGeometry(RADIUS, SEGMENTS, RINGS);
			const sphere = new THREE.Mesh(sphereGeometry, material);
			sphere.position.x = x;
			sphere.position.y = y;
			sphere.position.z = z;

			return sphere;
		}

		// plane
		var geometry = new THREE.PlaneGeometry(50, 20, 32);
		var material = new THREE.MeshBasicMaterial({
			color: 0xffff00,
			side: THREE.DoubleSide
		});
    var plane = new THREE.Mesh(geometry, material);
    plane.position.y = -10;
    plane.position.z = 1.7;
    plane.rotation.x = 11;
    scene.add(plane);
		var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
		hemiLight.position.set( 0, 500, 0 );
		scene.add( hemiLight );

		var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
		dirLight.position.set( -1, 0.75, 1 );
		dirLight.position.multiplyScalar( 50);
		dirLight.name = "dirlight";

		scene.add( dirLight );

		dirLight.castShadow = true;
		dirLight.shadow.mapSize.width = dirLight.shadow.mapSize.Height = 1024*2;

		var d = 300;

		dirLight.shadow.camera.left = -d;
		dirLight.shadow.camera.right = d;
		dirLight.shadow.camera.top = d;
		dirLight.shadow.camera.bottom = -d;

		// camera
    camera.position.z = 20;

		// loop
    function render() {
      objUpdate();
      sphereGenerator();
      renderer.render(scene, camera);
			requestAnimFrame(render);
    };
    var objUpdate = function () {
			var indexesToRemove = [];
			for (let obj of objArray) {
				obj.material.uniforms.time.value += 1;
				var time = obj.material.uniforms.time.value;
				if(obj.scale.x <= 13) {
					//obj.position.y -= 0.1;
					obj.position.y = 0.5 * -.01 * time * time + 0.5 * time + 10
					obj.position.z = -10 + 0.1 * time;
					obj.rotation.y -= 0.1;
					obj.scale.x = 1+0.002 * time;
					obj.scale.y = 1 + 0.002 * time;
					obj.scale.z = 1 + 0.002 * time;
					if (obj.position.y < -10 + 3) {
						indexesToRemove.push(objArray.indexOf(obj));
					}
				}
			}
			for (let index of indexesToRemove) {
				scene.remove(objArray[index]);
				objArray.splice(index, 1);
			}
    }
		var time = 0;
    var sphereGenerator = function () {
			++time;
      if (time % 100 === 1) {
        var newSphere = createSphere(Math.random()*20-10, 10, -10);
        scene.add(newSphere);
				objArray.push(newSphere);
      }
    }
		requestAnimFrame(render);
    </script>
  </body>
</html>
